<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Parareal</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="theme.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
  <!-- pandoc-eqnos: equation style -->
  <style>
    .eqnos { display: inline-block; position: relative; width: 100%; }
    .eqnos br { display: none; }
    .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Parareal</h1>
<p class="subtitle">a library for parallel-in-time computations in Python</p>
<!--        <div id="dark-mode-toggle">
                <p>Dark mode: <button class="dark-mode-button"
                        aria-label="Toggle dark mode"
                        onclick="toggle_dark_mode()">
                        <span></span><span></span>
                </button></p>
</div> -->
</header>
<div class="row">
        <div class="col-6 col-s-9" id="main">
<p><a href="https://entangled.github.io/"><img src="https://img.shields.io/badge/entangled-Use%20the%20source!-%2300aeff" alt="Entangled badge" /></a></p>
<p>This package runs the parareal algorithm on a black-box simulator. Parallelisation is managed through Dask.</p>
<section id="license" class="level1">
<h1>License</h1>
<p>Apache 2, see <code>LICENSE</code>.</p>
</section>
<section id="parareal" class="level1">
<h1>Parareal</h1>
<div class="named-code-block">
<p>file:parareal/__init__.py</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> .tabulate_solution <span class="im">import</span> tabulate</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> .parareal <span class="im">import</span> parareal</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> . <span class="im">import</span> abstract</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>__all__ <span class="op">=</span> [<span class="st">&quot;tabulate&quot;</span>, <span class="st">&quot;parareal&quot;</span>, <span class="st">&quot;schedule&quot;</span>, <span class="st">&quot;abstract&quot;</span>]</span></code></pre></div>
</div>
<section id="components" class="level2">
<h2>Components</h2>
<p>We may present the Parareal algorithm in abstract terms, and match those terms with corresponding type definitions in Python.</p>
<p>We need to define the following:</p>
<blockquote>
<dl>
<dt><code>Vector</code></dt>
<dd><p>A <code>Vector</code> is an object that represents the state of a solution at any one time. On this state we need to be able to do addition, subtraction and scalar multiplication, in order to perform the Parareal algorithm.</p>
</dd>
<dt><code>Solution</code></dt>
<dd><p>A <code>Solution</code> is a function that takes an initial <code>Vector</code>, a time <code>t_0</code> and a time <code>t</code>, returning the state <code>Vector</code> at time <code>t</code>.</p>
</dd>
<dt><code>Mapping</code></dt>
<dd><p>A <code>Mapping</code> is a function from one state <code>Vector</code> to another, for example a mapping from a coarse to a fine mesh or vice-versa.</p>
</dd>
<dt>Fine <code>Solution</code></dt>
<dd><p>The <em>fine</em> solution is the solution at the desired resolution. If we were not doing parallel-in-time, this would be the integrator to get at the correct result. We may also use the fine solution to find a ground thruth in testing the Parareal solution.</p>
</dd>
<dt>Coarse <code>Solution</code></dt>
<dd><p>The <em>coarse</em> solution is the solution that is fast but less accurate.</p>
</dd>
</dl>
</blockquote>
<div class="named-code-block">
<p>file:parareal/abstract.py</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> __future__ <span class="im">import</span> annotations</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> (Callable, Protocol, TypeVar, Union)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>abstract<span class="op">-</span>types<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<section id="vector" class="level3">
<h3>Vector</h3>
<p>We have an ODE in the form</p>
<p><span id="eq:ode" class="eqnos"><span class="math display">\[y&#39; = f(y, t).\]</span><span class="eqnos-number">(1)</span></span></p>
<p>Here <span class="math inline">\(y\)</span> can be a scalar value, a vector of values (say a <code>numpy</code> array), or any expression of <em>state</em>. A naive implementation of an ODE integrator would be</p>
<p><span id="eq:euler-method" class="eqnos"><span class="math display">\[y_{n+1} = y_{n} + \Delta t f(y_{n}, t).\]</span><span class="eqnos-number">(2)</span></span></p>
<p>eq. <a href="#eq:euler-method">2</a> is known as the <em>forward Euler method</em>. We can capture the <em>state</em> <span class="math inline">\(y\)</span> in an abstract class we’ll call <code>Vector</code>. We chose this name because we expect this objects to share (some of) the arithmetic properties of mathematical vectors. Namely, we want to be able to add, subtract and scale them. The chunk below states this need of a basic arithmetic in the form of abstract methods.</p>
<div class="named-code-block">
<p>«abstract-types»</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>TVector <span class="op">=</span> TypeVar(<span class="st">&quot;TVector&quot;</span>, bound<span class="op">=</span><span class="st">&quot;Vector&quot;</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Vector(Protocol):</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__add__</span>(<span class="va">self</span>: TVector, other: TVector) <span class="op">-&gt;</span> TVector:</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        ...</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__sub__</span>(<span class="va">self</span>: TVector, other: TVector) <span class="op">-&gt;</span> TVector:</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        ...</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__mul__</span>(<span class="va">self</span>: TVector, other: <span class="bu">float</span>) <span class="op">-&gt;</span> TVector:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        ...</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__rmul__</span>(<span class="va">self</span>: TVector, other: <span class="bu">float</span>) <span class="op">-&gt;</span> TVector:</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        ...</span></code></pre></div>
</div>
<p><em>We don’t actually need to implement these methods right now. All this is saying, is that any type that has these methods defined can stand in for a <code>Vector</code>.</em></p>
<p>Note that we don’t make a formal distinction here between a state vector and a vector representing a change in state.</p>
<div class="named-code-block">
<p>«abstract-types»</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>Mapping <span class="op">=</span> Callable[[TVector], TVector]</span></code></pre></div>
</div>
</section>
<section id="problem" class="level3">
<h3>Problem</h3>
<p>An ODE is then given as a function taking a <code>Vector</code> (the state <span class="math inline">\(y\)</span>) and a <code>float</code> (the time <span class="math inline">\(t\)</span>) returning a <code>Vector</code> (the derivative <span class="math inline">\(y&#39; = f(y,t)\)</span> evaluated at <span class="math inline">\((y,t)\)</span>). We define the type <code>Problem</code>:</p>
<div class="named-code-block">
<p>«abstract-types»</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>Problem <span class="op">=</span> Callable[[TVector, <span class="bu">float</span>], TVector]</span></code></pre></div>
</div>
<p>In mathematical notation the snippet above means:</p>
<p><span class="math display">\[{\rm Problem} : (y, t) \to f(y, t) = y&#39;\]</span></p>
</section>
<section id="solution" class="level3">
<h3>Solution</h3>
<p>If we have a <code>Problem</code>, we’re after a <code>Solution</code>: a function that, given an initial <code>Vector</code> (the initial condition <span class="math inline">\(y_0\)</span>), initial time (<span class="math inline">\(t_0\)</span>) and final time (<span class="math inline">\(t\)</span>), gives the resulting <code>Vector</code> (the solution, <span class="math inline">\(y(t)\)</span> for the given initial conditions).</p>
<div class="named-code-block">
<p>«abstract-types»</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>Solution <span class="op">=</span> Union[Callable[[TVector, <span class="bu">float</span>, <span class="bu">float</span>], TVector],</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>                 Callable[..., TVector]]</span></code></pre></div>
</div>
<p>Those readers more familiar with classical physics or mathematics may notice that our <code>Problem</code> object corresponds with the function <span class="math inline">\(f\)</span> in (eq. <a href="#eq:ode">1</a>). The <code>Solution</code> object, on the other hand, corresponds with the evolution operator <span class="math inline">\(\phi\)</span> in equation <a href="#eq:solution">3</a>.</p>
<p><span id="eq:solution" class="eqnos"><span class="math display">\[{\rm Solution} : (y_0, t_0; t) \to \phi(y_0, t_0; t) = y.\]</span><span class="eqnos-number">(3)</span></span></p>
<p>Intuitively, <span class="math inline">\(\phi\)</span> represents any method that solves (even approximately) our initial value problem.</p>
<section id="example" class="level4">
<h4>Example</h4>
<p>An example of a <code>Problem</code> would be the function,</p>
<p><span class="math display">\[f(y, t) = r y,\]</span></p>
<p>in which case the corresponding <code>Solution</code> is,</p>
<p><span class="math display">\[\phi(y_0, t_0; t) = y_0 e^{r(t - t_0)}.\]</span></p>
</section>
</section>
<section id="solver" class="level3">
<h3>Solver</h3>
<p>The challenge is, of course, to find a way of transforming a <code>Problem</code> into a <code>Solution</code>. This is what integration algorithms, or <em>solvers</em> do:</p>
<p><span class="math display">\[{\rm Solver} : {\rm Problem} \to {\rm Solution}.\]</span></p>
<p>If we look a bit closely at the definitions of <code>Problem</code> and <code>Solution</code> we’ll notice that a solver is indeed a functional that accepts functions of <span class="math inline">\((y,t)\)</span> as an input and returns functions of <span class="math inline">\((y_0, t_0, t)\)</span> as an output.</p>
<p>An example of such a solver is the forward Euler method (eq. <a href="#eq:euler-method">2</a>), that can be implemented as:</p>
<div class="named-code-block">
<p>file:parareal/forward_euler.py</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> .abstract <span class="im">import</span> (Vector, Problem, Solution)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> forward_euler(f: Problem) <span class="op">-&gt;</span> Solution:</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Forward-Euler solver.&quot;&quot;&quot;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> step(y: Vector, t_0: <span class="bu">float</span>, t_1: <span class="bu">float</span>) <span class="op">-&gt;</span> Vector:</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Stepping function of Euler method.&quot;&quot;&quot;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> y <span class="op">+</span> (t_1 <span class="op">-</span> t_0) <span class="op">*</span> f(y, t_0)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> step</span></code></pre></div>
</div>
<p>Any existing solution can be iterated over to provide a solution over a larger time interval. The <code>iterate_solution</code> function runs a given solution with a step-size fixed to <span class="math inline">\(\Delta t = h\)</span>.</p>
<!--$${\rm Iter}[S, h]\Big|_{t_0, y = y}^{t_1} = \begin{cases}-->
<!--y & t_0 = t_1 \\-->
<!--{\rm Iter}[S, h]\big|_{t_0 + h, y = S(y, t_0, t_0 + h)}^{t_1} & {\rm otherwise}-->
<!--\end{cases}.$$-->
<div class="named-code-block">
<p>file:parareal/iterate_solution.py</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> .abstract <span class="im">import</span> (Vector, Solution)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> iterate_solution(step: Solution, h: <span class="bu">float</span>) <span class="op">-&gt;</span> Solution:</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> iter_step(y: Vector, t_0: <span class="bu">float</span>, t_1: <span class="bu">float</span>) <span class="op">-&gt;</span> Vector:</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Stepping function of iterated solution.&quot;&quot;&quot;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> math.ceil((t_1 <span class="op">-</span> t_0) <span class="op">/</span> h)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        steps <span class="op">=</span> np.linspace(t_0, t_1, n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> t_a, t_b <span class="kw">in</span> <span class="bu">zip</span>(steps[:<span class="op">-</span><span class="dv">1</span>], steps[<span class="dv">1</span>:]):</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>            y <span class="op">=</span> step(y, t_a, t_b)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> y</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> iter_step</span></code></pre></div>
</div>
<section id="example-damped-harmonic-oscillator" class="level4">
<h4>Example: damped harmonic oscillator</h4>
<p>We give a bit more attention to the example of the harmonic oscillator, because it will also serve as a first test case for the Parareal algorithm later on.</p>
<p>The harmonic oscillator can model the movement of a pendulum or the vibration of a mass on a string.</p>
<p><span class="math display">\[y&#39;&#39; + 2\zeta \omega_0 y&#39; + \omega_0^2 y = 0,\]</span></p>
<p>where <span class="math inline">\(\omega_0 = \sqrt{k/m}\)</span> and <span class="math inline">\(\zeta = c / 2\sqrt{mk}\)</span>, <span class="math inline">\(k\)</span> being the spring constant, <span class="math inline">\(m\)</span> the test mass and <span class="math inline">\(c\)</span> the friction constant.</p>
<p>To solve this second order ODE we need to introduce a second variable to solve for. Say <span class="math inline">\(q = y\)</span> and <span class="math inline">\(p = y&#39;\)</span>.</p>
<p><span id="eq:harmonic-oscillator" class="eqnos"><span class="math display">\[\begin{aligned}
    q&#39; &amp;= p\\
    p&#39; &amp;= -2\zeta \omega_0 p + \omega_0^2 q
\end{aligned}\]</span><span class="eqnos-number">(4)</span></span> </p>
<p>The <code>Problem</code> is then given as</p>
<div class="named-code-block">
<p>file:parareal/harmonic_oscillator.py</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> .abstract <span class="im">import</span> (Problem)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Callable</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.typing <span class="im">import</span> NDArray</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> harmonic_oscillator(omega_0: <span class="bu">float</span>, zeta: <span class="bu">float</span>) <span class="op">-&gt;</span> Problem:</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> f(y, t):</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.r_[y[<span class="dv">1</span>], <span class="op">-</span><span class="dv">2</span> <span class="op">*</span> zeta <span class="op">*</span> omega_0 <span class="op">*</span> y[<span class="dv">1</span>] <span class="op">-</span> omega_0<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> y[<span class="dv">0</span>]]</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> f</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>harmonic<span class="op">-</span>oscillator<span class="op">-</span>solution<span class="op">&gt;&gt;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> numpy <span class="im">as</span> np  <span class="co"># type: ignore</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> pandas <span class="im">as</span> pd  <span class="co"># type: ignore</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> plotnine <span class="im">import</span> ggplot, geom_line, aes  <span class="co"># type: ignore</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> pintFoam.parareal.harmonic_oscillator <span class="im">import</span> harmonic_oscillator</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> pintFoam.parareal.forward_euler <span class="im">import</span> forward_euler</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> pintFoam.parareal.iterate_solution <span class="im">import</span> iterate_solution</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> pintFoam.parareal.tabulate_solution <span class="im">import</span> tabulate_np</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    OMEGA0 <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>    ZETA <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    H <span class="op">=</span> <span class="fl">0.001</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    system <span class="op">=</span> harmonic_oscillator(OMEGA0, ZETA)</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> coarse(y, t0, t1):</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> forward_euler(system)(y, t0, t1)</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># fine :: Solution[NDArray]</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fine(y, t0, t1):</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> iterate_solution(forward_euler(system), H)(y, t0, t1)</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>    y0 <span class="op">=</span> np.array([<span class="fl">1.0</span>, <span class="fl">0.0</span>])</span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.linspace(<span class="fl">0.0</span>, <span class="fl">15.0</span>, <span class="dv">100</span>)</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>    exact_result <span class="op">=</span> underdamped_solution(OMEGA0, ZETA)(t)</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>    euler_result <span class="op">=</span> tabulate_np(fine, y0, t)</span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> pd.DataFrame({</span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;time&quot;</span>: t,</span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;exact_q&quot;</span>: exact_result[:,<span class="dv">0</span>],</span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;exact_p&quot;</span>: exact_result[:,<span class="dv">1</span>],</span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;euler_q&quot;</span>: euler_result[:,<span class="dv">0</span>],</span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;euler_p&quot;</span>: euler_result[:,<span class="dv">1</span>]})</span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>    plot <span class="op">=</span> ggplot(data) <span class="op">\</span></span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span> geom_line(aes(<span class="st">&quot;time&quot;</span>, <span class="st">&quot;exact_q&quot;</span>)) <span class="op">\</span></span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a>        <span class="op">+</span> geom_line(aes(<span class="st">&quot;time&quot;</span>, <span class="st">&quot;euler_q&quot;</span>), color<span class="op">=</span><span class="st">&quot;#000088&quot;</span>)</span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>    plot.save(<span class="st">&quot;plot.svg&quot;</span>)</span></code></pre></div>
</div>
</section>
<section id="exact-solution" class="level4">
<h4>Exact solution</h4>
<p>The damped harmonic oscillator has an exact solution, given the ansatz <span class="math inline">\(y = A \exp(z t)\)</span>, we get</p>
<p><span class="math display">\[z_{\pm} = \omega_0\left(-\zeta \pm \sqrt{\zeta^2 - 1}\right).\]</span></p>
<p>and thus the general solution:</p>
<p><span class="math display">\[y(t) = A \exp(z_+ t) + B \exp(z_- t) \ : \zeta \neq 1 \]</span> <span class="math display">\[y(t) = (A + Bt) \exp(-\omega_0 t) : \zeta = 1 \]</span></p>
<p>This dynamical system has three qualitatively different solutions, each of them depending on the sign of the contents of the square root. Particularly, if the contents of the square root are negative, the two possible values for <span class="math inline">\(z\)</span> will be complex numbers, making oscillations possible. More specifically, the three cases are:</p>
<ul>
<li><em>overdamped</em> (<span class="math inline">\(\zeta &gt; 1\)</span> and, thus, both <span class="math inline">\(z\)</span> are real numbers)</li>
<li><em>critical dampening</em> (<span class="math inline">\(\zeta = 1\)</span> and <span class="math inline">\(z\)</span> is real and equal to <span class="math inline">\(-\omega_0\)</span>)</li>
<li><em>underdamped</em> (<span class="math inline">\(\mid \zeta \mid &lt; 1\)</span>, and <span class="math inline">\(z = -\omega_0\zeta \mp i \omega_0 \sqrt{1 - \zeta^2}\)</span>).</li>
</ul>
<p>The underdamped case is typically the most interesting one. In this case we have solutions of the form:</p>
<p><span class="math display">\[y = A\quad \underbrace{\exp(-\omega_0\zeta t)}_{\rm dampening}\quad\underbrace{\exp(\pm i \omega_0 \sqrt{1 - \zeta^2} t)}_{\rm oscillation},\]</span></p>
<p>Given an initial condition <span class="math inline">\(q_0 = 1, p_0 = 0\)</span>, the solution is computed as</p>
<div class="named-code-block">
<p>«harmonic-oscillator-solution»</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> underdamped_solution(omega_0: <span class="bu">float</span>, zeta: <span class="bu">float</span>) <span class="op">\</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>        <span class="op">-&gt;</span> Callable[[NDArray[np.float64]], NDArray[np.float64]]:</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    amp   <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> zeta<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    phase <span class="op">=</span> np.arcsin(zeta)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    freq  <span class="op">=</span> omega_0 <span class="op">*</span> np.sqrt(<span class="dv">1</span> <span class="op">-</span> zeta<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> f(t: NDArray[np.float64]) <span class="op">-&gt;</span> NDArray[np.float64]:</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        dampening <span class="op">=</span> np.exp(<span class="op">-</span>omega_0<span class="op">*</span>zeta<span class="op">*</span>t)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> amp <span class="op">*</span> dampening <span class="op">*</span> np.cos(freq <span class="op">*</span> t <span class="op">-</span> phase)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="op">-</span> amp <span class="op">*</span> omega_0 <span class="op">*</span> dampening <span class="op">*</span> np.sin(freq <span class="op">*</span> t)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.c_[q, p]</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> f</span></code></pre></div>
</div>
</section>
<section id="numeric-solution" class="level4">
<h4>Numeric solution</h4>
<p>To plot a <code>Solution</code>, we need to tabulate the results for a given sequence of time points.</p>
<div class="named-code-block">
<p>file:parareal/tabulate_solution.py</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> .abstract <span class="im">import</span> (Solution, Vector)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> (Sequence, Any)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>Array <span class="op">=</span> Any</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tabulate(step: Solution, y_0: Vector, t: Array) <span class="op">-&gt;</span> Sequence[Vector]:</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Tabulate the step-wise solution, starting from `y_0`, for every time</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co">    point given in array `t`.&quot;&quot;&quot;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(y_0, np.ndarray):</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> tabulate_np(step, y_0, t)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> [y_0]</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, t.size):</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        y_i <span class="op">=</span> step(y[i<span class="op">-</span><span class="dv">1</span>], t[i<span class="op">-</span><span class="dv">1</span>], t[i])</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        y.append(y_i)</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>tabulate<span class="op">-</span>np<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>In the case that the <code>Vector</code> type is actually a numpy array, we can specialize the <code>tabulate</code> routine to return a larger array.</p>
<div class="named-code-block">
<p>«tabulate-np»</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tabulate_np(step: Solution, y_0: Array, t: Array) <span class="op">-&gt;</span> Array:</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.zeros(dtype<span class="op">=</span>y_0.dtype, shape<span class="op">=</span>(t.size,) <span class="op">+</span> y_0.shape)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    y[<span class="dv">0</span>] <span class="op">=</span> y_0</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, t.size):</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        y[i] <span class="op">=</span> step(y[i<span class="op">-</span><span class="dv">1</span>], t[i<span class="op">-</span><span class="dv">1</span>], t[i])</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y</span></code></pre></div>
</div>
<p>We can compare the results from the numeric integration with the exact solution.</p>
<p><img src="img/harmonic.svg" title="Damped harmonic oscillator" class="figure" alt="Damped harmonic oscillator" /></p>
</section>
</section>
</section>
<section id="parareal-1" class="level2">
<h2>Parareal</h2>
<p>From Wikipedia:</p>
<blockquote>
<p>Parareal solves an initial value problem of the form</p>
<p><span class="math display">\[\dot{y}(t) = f(y(t), t), \quad y(t_0) = y_0 \quad \text{with} \quad t_0 \leq t \leq T.\]</span></p>
<p>Here, the right hand side <span class="math inline">\(f\)</span> can correspond to the spatial discretization of a partial differential equation in a method of lines approach. Parareal now requires a decomposition of the time interval <span class="math inline">\([t_0, T]\)</span> into <span class="math inline">\(P\)</span> so-called time slices <span class="math inline">\([t_j, t_{j+1}]\)</span> such that</p>
<p><span class="math display">\[[t_0, T] = [t_0, t_1] \cup [t_1, t_2] \cup \ldots \cup [t_{P-1}, t_{P} ].\]</span></p>
<p>Each time slice is assigned to one processing unit when parallelizing the algorithm, so that <span class="math inline">\(P\)</span> is equal to the number of processing units used for Parareal.</p>
<p>Parareal is based on the iterative application of two methods for integration of ordinary differential equations. One, commonly labelled <span class="math inline">\({\mathcal {F}}\)</span>, should be of high accuracy and computational cost while the other, typically labelled <span class="math inline">\({\mathcal {G}}\)</span>, must be computationally cheap but can be much less accurate. Typically, some form of Runge-Kutta method is chosen for both coarse and fine integrator, where <span class="math inline">\({\mathcal {G}}\)</span> might be of lower order and use a larger time step than <span class="math inline">\({\mathcal {F}}\)</span>. If the initial value problem stems from the discretization of a PDE, <span class="math inline">\({\mathcal {G}}\)</span> can also use a coarser spatial discretization, but this can negatively impact convergence unless high order interpolation is used. The result of numerical integration with one of these methods over a time slice <span class="math inline">\([t_{j}, t_{j+1}]\)</span> for some starting value <span class="math inline">\(y_{j}\)</span> given at <span class="math inline">\(t_{j}\)</span> is then written as</p>
<p><span class="math display">\[y = \mathcal{F}(y_j, t_j, t_{j+1})\ {\rm or}\ y = \mathcal{G}(y_j, t_j, t_{j+1}).\]</span></p>
<p>Serial time integration with the fine method would then correspond to a step-by-step computation of</p>
<p><span class="math display">\[y_{j+1} = \mathcal{F}(y_j, t_j, t_{j+1}), \quad j=0, \ldots, P-1.\]</span></p>
<p>Parareal instead uses the following iteration</p>
<p><span class="math display">\[y_{j+1}^{k+1} = \mathcal{G}(y^{k+1}_j, t_j, t_{j+1}) + \mathcal{F}(y^k_j, t_j, t_{j+1}) - \mathcal{G}(y^k_j, t_j, t_{j+1}),\\ \quad j=0, \ldots, P-1, \quad k=0, \ldots, K-1,\]</span></p>
<p>where <span class="math inline">\(k\)</span> is the iteration counter. As the iteration converges and <span class="math inline">\(y^{k+1}_j - y^k_j \to 0\)</span>, the terms from the coarse method cancel out and Parareal reproduces the solution that is obtained by the serial execution of the fine method only. It can be shown that Parareal converges after a maximum of <span class="math inline">\(P\)</span> iterations. For Parareal to provide speedup, however, it has to converge in a number of iterations significantly smaller than the number of time slices, that is <span class="math inline">\(K \ll P\)</span>.</p>
<p>In the Parareal iteration, the computationally expensive evaluation of <span class="math inline">\(\mathcal{F}(y^k_j, t_j, t_{j+1})\)</span> can be performed in parallel on <span class="math inline">\(P\)</span> processing units. By contrast, the dependency of <span class="math inline">\(y^{k+1}_{j+1}\)</span> on <span class="math inline">\(\mathcal{G}(y^{k+1}_j, t_j, t_{j+1})\)</span> means that the coarse correction has to be computed in serial order.</p>
</blockquote>
<p>Don’t get blinded by the details of the algorithm. After all, everything boils down to an update equation that uses a state vector <span class="math inline">\(y\)</span> to calculate the state at the immediately next future step (in the same fashion as equation eq. <a href="#eq:euler-method">2</a> did). The core equation translates to:</p>
<div class="named-code-block">
<p>«parareal-core-1»</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>y_n[i] <span class="op">=</span> coarse(y_n[i<span class="op">-</span><span class="dv">1</span>], t[i<span class="op">-</span><span class="dv">1</span>], t[i]) <span class="op">\</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>       <span class="op">+</span> fine(y[i<span class="op">-</span><span class="dv">1</span>], t[i<span class="op">-</span><span class="dv">1</span>], t[i]) <span class="op">\</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>       <span class="op">-</span> coarse(y[i<span class="op">-</span><span class="dv">1</span>], t[i<span class="op">-</span><span class="dv">1</span>], t[i])</span></code></pre></div>
</div>
<p>If we include a <code>Mapping</code> between fine and coarse meshes into the equation, we get:</p>
<div class="named-code-block">
<p>«parareal-core-2»</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>y_n[i] <span class="op">=</span> c2f(coarse(f2c(y_n[i<span class="op">-</span><span class="dv">1</span>]), t[i<span class="op">-</span><span class="dv">1</span>], t[i])) <span class="op">\</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>       <span class="op">+</span> fine(y[i<span class="op">-</span><span class="dv">1</span>], t[i<span class="op">-</span><span class="dv">1</span>], t[i]) <span class="op">\</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>       <span class="op">-</span> c2f(coarse(f2c(y[i<span class="op">-</span><span class="dv">1</span>]), t[i<span class="op">-</span><span class="dv">1</span>], t[i]))</span></code></pre></div>
</div>
<p>The rest is boiler plate. For the <code>c2f</code> and <code>f2c</code> mappings we provide a default argument of the identity function.</p>
<div class="named-code-block">
<p>file:parareal/parareal.py</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> .abstract <span class="im">import</span> (Solution, Mapping)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> identity(x):</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parareal(</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        coarse: Solution,</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        fine: Solution,</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>        c2f: Mapping <span class="op">=</span> identity,</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        f2c: Mapping <span class="op">=</span> identity):</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> f(y, t):</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        m <span class="op">=</span> t.size</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>        y_n <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> m</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        y_n[<span class="dv">0</span>] <span class="op">=</span> y[<span class="dv">0</span>]</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">&lt;&lt;</span>parareal<span class="op">-</span>core<span class="op">-</span><span class="dv">2</span><span class="op">&gt;&gt;</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> y_n</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> f</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parareal_np(</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>        coarse: Solution,</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>        fine: Solution,</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>        c2f: Mapping <span class="op">=</span> identity,</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>        f2c: Mapping <span class="op">=</span> identity):</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> f(y, t):</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>        m <span class="op">=</span> t.size</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>        y_n <span class="op">=</span> np.zeros_like(y)</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>        y_n[<span class="dv">0</span>] <span class="op">=</span> y[<span class="dv">0</span>]</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">&lt;&lt;</span>parareal<span class="op">-</span>core<span class="op">-</span><span class="dv">2</span><span class="op">&gt;&gt;</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> y_n</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> f</span></code></pre></div>
</div>
</section>
<section id="running-in-parallel" class="level2">
<h2>Running in parallel</h2>
<div class="named-code-block">
<p>«import-dask»</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dask <span class="im">import</span> delayed  <span class="co"># type: ignore</span></span></code></pre></div>
</div>
<p>To see what Dask does, first we’ll daskify the direct integration routine in <code>tabulate</code>. We take the same harmonic oscillator we had before. For the sake of argument let’s divide the time line in three steps (so four points).</p>
<div class="named-code-block">
<p>«daskify»</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>omega_0 <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>zeta <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> harmonic_oscillator(omega_0, zeta)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="fl">0.0</span>, <span class="fl">15.0</span>, <span class="dv">4</span>)</span></code></pre></div>
</div>
<p>We now define the <code>fine</code> integrator:</p>
<div class="named-code-block">
<p>«daskify»</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="fl">0.01</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="at">@green</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="at">@delayed</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fine(x, t_0, t_1):</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> iterate_solution(forward_euler(f), h)(x, t_0, t_1)</span></code></pre></div>
</div>
<p>It doesn’t really matter what the fine integrator does, since we won’t run anything. We’ll just pretend. The <code>delayed</code> decorator makes sure that the integrator is never called, we just store the information that we <em>want</em> to call the <code>fine</code> function. The resulting value is a <em>promise</em> that at some point we <em>will</em> call the <code>fine</code> function. The nice thing is, that this promise behaves like any other Python object, it even qualifies as a <code>Vector</code>! The <code>tabulate</code> routine returns a <code>Sequence</code> of <code>Vector</code>s, in this case a list of promises. The <code>gather</code> function takes a list of promises and turns it into a promise of a list.</p>
<div class="named-code-block">
<p>«daskify»</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>y_euler <span class="op">=</span> tabulate(fine, [<span class="fl">1.0</span>, <span class="fl">0.0</span>], t)</span></code></pre></div>
</div>
<p>We can draw the resulting workflow:</p>
<p><img src="img/seq-graph.svg" title="Sequential integration" class="figure" alt="Sequential integration" /></p>
<p>This workflow is entirely sequential, every step depending on the preceding one. Now for Parareal! We also define the <code>coarse</code> integrator.</p>
<div class="named-code-block">
<p>«daskify»</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="at">@delayed</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> coarse(x, t_0, t_1):</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> forward_euler(f)(x, t_0, t_1)</span></code></pre></div>
</div>
<p>Parareal is initialised with the ODE integrated by the coarse integrator, just like we did before with the fine one.</p>
<div class="named-code-block">
<p>«daskify»</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>y_first <span class="op">=</span> tabulate(coarse, [<span class="fl">1.0</span>, <span class="fl">0.0</span>], t)</span></code></pre></div>
</div>
<p>We can now perform a single iteration of Parareal to see what the workflow looks like:</p>
<div class="named-code-block">
<p>«daskify»</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>y_parareal <span class="op">=</span> gather(<span class="op">*</span>parareal(coarse, fine)(y_first, t))</span></code></pre></div>
</div>
<p><img src="img/parareal-graph.svg" title="Parareal iteration; the fine integrators (marked with blue squares) can be run in parallel." class="figure" alt="Parareal iteration; the fine integrators (marked with blue squares) can be run in parallel." /></p>
</section>
</section>
<section id="implementation-of-parareal-using-futures" class="level1">
<h1>Implementation of Parareal using Futures</h1>
<p>We reimplement Parareal in the <code>futures</code> framework of Dask. We have a few helper functions: <code>identity</code> to be used as default instance for the mappings between coarse and fine meshes, and <code>pairs</code>, a function that iterates through successive pairs of a list.</p>
<div class="named-code-block">
<p>file:parareal/futures.py</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> .abstract <span class="im">import</span> (Solution, Mapping, Vector)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> (Callable)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dataclasses <span class="im">import</span> dataclass</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> ceil</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.typing <span class="im">import</span> NDArray</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dask.distributed <span class="im">import</span> Client, Future  <span class="co"># type: ignore</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> logging</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> identity(x):</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pairs(lst):</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">zip</span>(lst[:<span class="op">-</span><span class="dv">1</span>], lst[<span class="dv">1</span>:])</span></code></pre></div>
</div>
<p>We need to send every operation to a remote worker, that includes summing the vectors from coarse and fine integrators.</p>
<div class="named-code-block">
<p>«parareal-futures»</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> combine(c1: Vector, f1: Vector, c2: Vector) <span class="op">-&gt;</span> Vector:</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c1 <span class="op">+</span> f1 <span class="op">-</span> c2</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«time-windows»</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> time_windows(times, window_size):</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Split the times vector in a set of time windows of a given size.</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="co">        times:          The times vector</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="co">        window_size:    The number of steps per window (note that n steps</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="co">        correspond to n + 1 elements in the window). The last window may</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="co">        be smaller.</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    n_intervals <span class="op">=</span> <span class="bu">len</span>(times) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">int</span>(ceil(n_intervals <span class="op">/</span> window_size))</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> window_size</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [times[i<span class="op">*</span>m:<span class="bu">min</span>(i<span class="op">*</span>m<span class="op">+</span>m<span class="op">+</span><span class="dv">1</span>, <span class="bu">len</span>(times))] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)]</span></code></pre></div>
</div>
<p>Every call that actually requires some of the data needs to be sent to the remote worker(s). Where we could get away before with putting everything in a closure, now it is easier to make a class that includes the Dask <code>Client</code> instance.</p>
<div class="named-code-block">
<p>«parareal-futures»</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Parareal:</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    client: Client</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    coarse: Callable[[<span class="bu">int</span>], Solution]</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    fine: Callable[[<span class="bu">int</span>], Solution]</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    c2f: Mapping <span class="op">=</span> identity</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    f2c: Mapping <span class="op">=</span> identity</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _c2f(<span class="va">self</span>, x: Future) <span class="op">-&gt;</span> Future:</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.c2f <span class="kw">is</span> identity:</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> x</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.client.submit(<span class="va">self</span>.c2f, x)</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _f2c(<span class="va">self</span>, x: Future) <span class="op">-&gt;</span> Future:</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.f2c <span class="kw">is</span> identity:</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> x</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.client.submit(<span class="va">self</span>.f2c, x)</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _coarse(<span class="va">self</span>, n_iter: <span class="bu">int</span>, y: Future, t0: <span class="bu">float</span>, t1: <span class="bu">float</span>) <span class="op">-&gt;</span>  Future:</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>        logging.debug(<span class="st">&quot;Coarse run: </span><span class="sc">%s</span><span class="st">, </span><span class="sc">%s</span><span class="st">, </span><span class="sc">%s</span><span class="st">&quot;</span>, y, t0, t1)</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.client.submit(<span class="va">self</span>.coarse(n_iter), y, t0, t1)</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _fine(<span class="va">self</span>, n_iter: <span class="bu">int</span>, y: Future, t0: <span class="bu">float</span>, t1: <span class="bu">float</span>) <span class="op">-&gt;</span> Future:</span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>        logging.debug(<span class="st">&quot;Fine run: </span><span class="sc">%s</span><span class="st">, </span><span class="sc">%s</span><span class="st">, </span><span class="sc">%s</span><span class="st">&quot;</span>, y, t0, t1)</span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.client.submit(<span class="va">self</span>.fine(n_iter), y, t0, t1)</span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>parareal<span class="op">-</span>methods<span class="op">&gt;&gt;</span></span></code></pre></div>
</div>
<p>The <code>step</code> method implements the core parareal algorithm.</p>
<div class="named-code-block">
<p>«parareal-methods»</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> step(<span class="va">self</span>, n_iter: <span class="bu">int</span>, y_prev: <span class="bu">list</span>[Future], t: NDArray[np.float64]) <span class="op">-&gt;</span> <span class="bu">list</span>[Future]:</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> t.size</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    y_next <span class="op">=</span> [<span class="va">None</span>] <span class="op">*</span> m</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    y_next[<span class="dv">0</span>] <span class="op">=</span> y_prev[<span class="dv">0</span>]</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>        c1 <span class="op">=</span> <span class="va">self</span>._c2f(<span class="va">self</span>._coarse(n_iter, <span class="va">self</span>.f2c(y_next[i<span class="op">-</span><span class="dv">1</span>]), t[i<span class="op">-</span><span class="dv">1</span>], t[i]))</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>        f1 <span class="op">=</span> <span class="va">self</span>._fine(n_iter, y_prev[i<span class="op">-</span><span class="dv">1</span>], t[i<span class="op">-</span><span class="dv">1</span>], t[i])</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>        c2 <span class="op">=</span> <span class="va">self</span>._c2f(<span class="va">self</span>._coarse(n_iter, <span class="va">self</span>.f2c(y_prev[i<span class="op">-</span><span class="dv">1</span>]), t[i<span class="op">-</span><span class="dv">1</span>], t[i]))</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>        y_next[i] <span class="op">=</span> <span class="va">self</span>.client.submit(combine, c1, f1, c2)</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y_next</span></code></pre></div>
</div>
<p>We schedule every possible iteration of parareal as a future. The tactic is to cancel remaining jobs only once we found a converging result. This way, workers can compute next iterations, even if the last step of the previous iteration is not yet complete and tested for convergence.</p>
<div class="named-code-block">
<p>«parareal-methods»</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> schedule(<span class="va">self</span>, y_0: Vector, t: NDArray[np.float64]) <span class="op">-&gt;</span> <span class="bu">list</span>[<span class="bu">list</span>[Future]]:</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># schedule initial coarse integration</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    y_init <span class="op">=</span> [<span class="va">self</span>.client.scatter(y_0)]</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (a, b) <span class="kw">in</span> pairs(t):</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>        y_init.append(<span class="va">self</span>._coarse(<span class="dv">0</span>, y_init[<span class="op">-</span><span class="dv">1</span>], a, b))</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># schedule all iterations of parareal</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    jobs <span class="op">=</span> [y_init]</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n_iter <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(t)):</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>        jobs.append(<span class="va">self</span>.step(n_iter<span class="op">+</span><span class="dv">1</span>, jobs[<span class="op">-</span><span class="dv">1</span>], t))</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> jobs</span></code></pre></div>
</div>
<p>The <code>wait</code> method then gathers results and returns the first iteration that satisfies <code>convergence_test</code>.</p>
<div class="named-code-block">
<p>«parareal-methods»</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> wait(<span class="va">self</span>, jobs, convergence_test):</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(jobs)):</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> <span class="va">self</span>.client.gather(jobs[i])</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> convergence_test(result):</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> jobs[i<span class="op">+</span><span class="dv">1</span>:]:</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.client.cancel(j)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> result</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code></pre></div>
</div>
<section id="harmonic-oscillator" class="level2">
<h2>Harmonic oscillator</h2>
<p>We may test this on the harmonic oscillator.</p>
<div class="named-code-block">
<p>file:test/test_futures.py</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dataclasses <span class="im">import</span> dataclass, field</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> partial</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> logging</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.typing <span class="im">import</span> NDArray</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> parareal.futures <span class="im">import</span> Parareal</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> parareal.harmonic_oscillator <span class="im">import</span> harmonic_oscillator</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> parareal.forward_euler <span class="im">import</span> forward_euler</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> parareal.iterate_solution <span class="im">import</span> iterate_solution</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> parareal.tabulate_solution <span class="im">import</span> tabulate</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dask.distributed <span class="im">import</span> Client  <span class="co"># type: ignore</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>OMEGA0 <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>ZETA <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> <span class="fl">0.001</span></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>system <span class="op">=</span> harmonic_oscillator(OMEGA0, ZETA)</span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> coarse(_, y, t0, t1):</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> forward_euler(system)(y, t0, t1)</span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fine(_, y, t0, t1):</span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> iterate_solution(forward_euler(system), H)(y, t0, t1)</span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> History:</span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a>    history: <span class="bu">list</span>[NDArray[np.float64]] <span class="op">=</span> field(default_factory<span class="op">=</span><span class="bu">list</span>)</span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> convergence_test(<span class="va">self</span>, y):</span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.history.append(np.array(y))</span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>        logging.debug(<span class="st">&quot;got result: </span><span class="sc">%s</span><span class="st">&quot;</span>, <span class="va">self</span>.history[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.history) <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.allclose(<span class="va">self</span>.history[<span class="op">-</span><span class="dv">1</span>], <span class="va">self</span>.history[<span class="op">-</span><span class="dv">2</span>], atol<span class="op">=</span><span class="fl">1e-4</span>)</span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_parareal():</span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a>    client <span class="op">=</span> Client()</span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> Parareal(client, <span class="kw">lambda</span> n: partial(coarse, n), <span class="kw">lambda</span> n: partial(fine, n))</span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.linspace(<span class="fl">0.0</span>, <span class="fl">15.0</span>, <span class="dv">30</span>)</span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true" tabindex="-1"></a>    y0 <span class="op">=</span> np.array([<span class="fl">0.0</span>, <span class="fl">1.0</span>])</span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true" tabindex="-1"></a>    history <span class="op">=</span> History()</span>
<span id="cb30-48"><a href="#cb30-48" aria-hidden="true" tabindex="-1"></a>    jobs <span class="op">=</span> p.schedule(y0, t)</span>
<span id="cb30-49"><a href="#cb30-49" aria-hidden="true" tabindex="-1"></a>    p.wait(jobs, history.convergence_test)</span>
<span id="cb30-50"><a href="#cb30-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-51"><a href="#cb30-51" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb30-52"><a href="#cb30-52" aria-hidden="true" tabindex="-1"></a>    logging.basicConfig(level<span class="op">=</span>logging.DEBUG)</span>
<span id="cb30-53"><a href="#cb30-53" aria-hidden="true" tabindex="-1"></a>    y0 <span class="op">=</span> np.array([<span class="fl">1.0</span>, <span class="fl">0.0</span>])</span>
<span id="cb30-54"><a href="#cb30-54" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.linspace(<span class="fl">0.0</span>, <span class="fl">15.0</span>, <span class="dv">30</span>)</span>
<span id="cb30-55"><a href="#cb30-55" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> tabulate(fine, y0, t)</span>
<span id="cb30-56"><a href="#cb30-56" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(result)</span></code></pre></div>
</div>
</section>
</section>
<section id="example-using-hdf5-and-mpi-and-dask-futures" class="level1">
<h1>Example: using HDF5 and MPI and Dask futures</h1>
<p>In this example, we look again at the example of a dampened harmonic oscillator. This time we will go in engineering overkill mode and show how a model can be scaled to a large compute cluster using Dask, MPI and HDF5 as intermediate storage. To avoid confusion and difficult software configuration, we won’t use the MPI feature of the HDF5 format. Instead, every job will write its output to its own HDF5 file.</p>
<p>This tutorial covers the following concepts: * delayed arithmetic expressions * defining the coarse and fine integrators * using MPI with Dask</p>
<section id="best-practices" class="level2">
<h2>Best practices</h2>
<p>The following shows some best practices when working with orchestrated computations. One is about using well established data standards, the other about reducing overhead on the distributed scheduler. We can solve both these issues by abstracting over the representation of the state vector in our system. This technique is definitely overkill for our harmonic oscillator example, but it is also in general a good recipe for running Numpy based simulations in an organized manner.</p>
<div class="named-code-block">
<p>file:examples/mpi_futures.py</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> __future__ <span class="im">import</span> annotations</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> argh  <span class="co"># type: ignore</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dataclasses <span class="im">import</span> dataclass, field</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> (Union, Callable, Optional, Any, Iterator)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>example<span class="op">-</span>mpi<span class="op">-</span>imports<span class="op">&gt;&gt;</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>vector<span class="op">-</span>expressions<span class="op">&gt;&gt;</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>example<span class="op">-</span>mpi<span class="op">-</span>coarse<span class="op">&gt;&gt;</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>example<span class="op">-</span>mpi<span class="op">-</span>fine<span class="op">&gt;&gt;</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>example<span class="op">-</span>mpi<span class="op">-</span>history<span class="op">&gt;&gt;</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_data(files: <span class="bu">list</span>[Path]) <span class="op">-&gt;</span> Iterator[np.ndarray]:</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n <span class="kw">in</span> files:</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> h5.File(n, <span class="st">&quot;r&quot;</span>) <span class="im">as</span> f:</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> f[<span class="st">&quot;data&quot;</span>][:]</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> combine_fine_data(files: <span class="bu">list</span>[Path]) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> get_data(files)</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>    first <span class="op">=</span> <span class="bu">next</span>(data)</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.concatenate([first] <span class="op">+</span> [x[<span class="dv">1</span>:] <span class="cf">for</span> x <span class="kw">in</span> data], axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a><span class="co"># def list_files(path: Path) -&gt; list[Path]:</span></span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a><span class="co">#     all_files = path.glob(&quot;*.h5&quot;)</span></span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a><span class="co">#     return []</span></span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> main(log: <span class="bu">str</span> <span class="op">=</span> <span class="st">&quot;WARNING&quot;</span>, log_file: Optional[<span class="bu">str</span>] <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a>         OMEGA0<span class="op">=</span><span class="fl">1.0</span>, ZETA<span class="op">=</span><span class="fl">0.5</span>, H<span class="op">=</span><span class="fl">0.01</span>):</span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Run model of dampened hormonic oscillator in Dask&quot;&quot;&quot;</span></span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a>    log_level <span class="op">=</span> <span class="bu">getattr</span>(logging, log.upper(), <span class="va">None</span>)</span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(log_level, <span class="bu">int</span>):</span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;Invalid log level `</span><span class="sc">{</span>log<span class="sc">}</span><span class="ss">`&quot;</span>)</span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true" tabindex="-1"></a>    logging.basicConfig(level<span class="op">=</span>log_level, filename<span class="op">=</span>log_file)</span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>example<span class="op">-</span>mpi<span class="op">-</span>main<span class="op">&gt;&gt;</span></span>
<span id="cb31-36"><a href="#cb31-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-37"><a href="#cb31-37" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb31-38"><a href="#cb31-38" aria-hidden="true" tabindex="-1"></a>    argh.dispatch_command(main)</span></code></pre></div>
</div>
</section>
<section id="dask-with-mpi" class="level2">
<h2>Dask with MPI</h2>
<p>There are two modes in which we may run Dask with MPI. One with a <code>dask-mpi</code> running as external scheduler, the other running everything as a single script. For this example we opt for the second, straight from the dask-mpi documentation:</p>
<div class="named-code-block">
<p>«example-mpi-imports»</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dask_mpi <span class="im">import</span> initialize  <span class="co"># type: ignore</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dask.distributed <span class="im">import</span> Client  <span class="co"># type: ignore</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«example-mpi-main»</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>initialize()</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>client <span class="op">=</span> Client()</span></code></pre></div>
</div>
</section>
<section id="vector-arithmetic-expressions" class="level2">
<h2>Vector Arithmetic Expressions</h2>
<section id="abstract-vectors" class="level3">
<h3>Abstract vectors</h3>
<p>It may be convenient to treat our <code>Vector</code> operations such that they are only performed once their output is needed. That way, we only need to schedule the actual integration steps as external jobs. In the meantime we have to store the arithmetic in a serializable <code>Expression</code> value. By doing this we reduce the amount of jobs that have to be handled by the scheduler, but also we reduce the amount of data that is being written and read from the file system.</p>
<p>We will be using <code>functools.partial</code> and functions <code>operator.add</code>, <code>operator.mul</code> etc, to create a data structure that describes all the operations that we might do on a <code>Vector</code>. Results may be stored for reference in a <code>hdf5</code> file, a feature that can also be hidden behind our <code>Vector</code> interface.</p>
<div class="named-code-block">
<p>«example-mpi-imports»</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> operator</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> partial</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> h5py <span class="im">as</span> h5  <span class="co"># type: ignore</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> abc <span class="im">import</span> (ABC, abstractmethod)</span></code></pre></div>
</div>
<p>We create a <code>Vector</code> class that satisfies the <code>Vector</code> concept outlined earlier. We store the operations in terms of unary and binary operators.</p>
<div class="named-code-block">
<p>«vector-expressions»</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Vector(ABC):</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">@abstractmethod</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="bu">reduce</span>(<span class="va">self</span>: Vector) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__add__</span>(<span class="va">self</span>, other):</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> BinaryExpr(operator.add, <span class="va">self</span>, other)</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__sub__</span>(<span class="va">self</span>, other):</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> BinaryExpr(operator.sub, <span class="va">self</span>, other)</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__mul__</span>(<span class="va">self</span>, scale):</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> UnaryExpr(partial(operator.mul, scale), <span class="va">self</span>)</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__rmul__</span>(<span class="va">self</span>, scale):</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> UnaryExpr(partial(operator.mul, scale), <span class="va">self</span>)</span></code></pre></div>
</div>
<p>The <code>Vector</code> class acts as a base class for the implementation of <code>BinaryExpr</code> and <code>UnaryExpr</code>, so that we can nest expressions accordingly. To force computation of a <code>Vector</code>, we supply the <code>reduce_expr</code> function that, in an example of terrible duck-typing, calls the <code>reduce</code> method recursively, until an object is reached that doesn’t have the <code>reduce</code> method.</p>
<div class="named-code-block">
<p>«vector-expressions»</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reduce_expr(expr: Union[np.ndarray, Vector]) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">isinstance</span>(expr, Vector):</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>        expr <span class="op">=</span> expr.<span class="bu">reduce</span>()</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> expr</span></code></pre></div>
</div>
</section>
<section id="hdf5-vectors" class="level3">
<h3>HDF5 Vectors</h3>
<p>This means we can also hide variables that are stored in an HDF5 file behind this interface. We often want to store more information than just the state vector. In the case of parareal, we have results from fine integration and coarse integration. In the case of fine integration, what we need to represent is the final state of the integration, but we are also interested in the intermediate steps.</p>
<div class="named-code-block">
<p>«vector-expressions»</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> H5Snap(Vector):</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    path: Path</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    loc: <span class="bu">str</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">slice</span>: <span class="bu">list</span>[Union[<span class="va">None</span>, <span class="bu">int</span>, <span class="bu">slice</span>]]</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> data(<span class="va">self</span>):</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> h5.File(<span class="va">self</span>.path, <span class="st">&quot;r&quot;</span>) <span class="im">as</span> f:</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> f[<span class="va">self</span>.loc].<span class="fu">__getitem__</span>(<span class="bu">tuple</span>(<span class="va">self</span>.<span class="bu">slice</span>))</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="bu">reduce</span>(<span class="va">self</span>):</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.data()</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>        logger <span class="op">=</span> logging.getLogger()</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>        logger.debug(<span class="ss">f&quot;read </span><span class="sc">{x}</span><span class="ss"> from </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>path<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.data()</span></code></pre></div>
</div>
<p>To generate slices in a nice manner we can use a helper class:</p>
<div class="named-code-block">
<p>«vector-expressions»</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Index:</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__getitem__</span>(<span class="va">self</span>, idx):</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(idx, <span class="bu">tuple</span>):</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">list</span>(idx)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> [idx]</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>index <span class="op">=</span> Index()</span></code></pre></div>
</div>
<p>Then <code>index[a:b,c]</code> returns a list of slices <code>[slice(a,b), c]</code> (type <code>list[Union[None, int, slice]]</code>).</p>
</section>
<section id="operators" class="level3">
<h3>Operators</h3>
<p>There are two classes of operators, unary and binary (more arguments can usually be expressed as a composition of unary and binary forms). We store the arguments together with a function operating on the arguments. The function should be serializable (e.g. using <code>pickle</code>), meaning that <code>lambda</code> expressions are not allowed, but <code>partial</code> applications and functions in <code>operator</code> typically are ok.</p>
<div class="named-code-block">
<p>«vector-expressions»</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> UnaryExpr(Vector):</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    func: Callable[[np.ndarray], np.ndarray]</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    inp: Vector</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="bu">reduce</span>(<span class="va">self</span>):</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> reduce_expr(<span class="va">self</span>.inp)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.func(a)</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BinaryExpr(Vector):</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    func: Callable[[np.ndarray, np.ndarray], np.ndarray]</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>    inp1: Vector</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>    inp2: Vector</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="bu">reduce</span>(<span class="va">self</span>):</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> reduce_expr(<span class="va">self</span>.inp1)</span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> reduce_expr(<span class="va">self</span>.inp2)</span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.func(a, b)</span></code></pre></div>
</div>
</section>
<section id="literal-expressions" class="level3">
<h3>Literal expressions</h3>
<p>To bootstrap our computation we may need to define a <code>Vector</code> directly represented by a Numpy array.</p>
<div class="named-code-block">
<p>«vector-expressions»</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> LiteralExpr(Vector):</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    value: np.ndarray</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="bu">reduce</span>(<span class="va">self</span>):</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.value</span></code></pre></div>
</div>
</section>
</section>
<section id="running-the-harmonic-oscillator" class="level2">
<h2>Running the harmonic oscillator</h2>
<div class="named-code-block">
<p>«example-mpi-imports»</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> parareal.futures <span class="im">import</span> (Parareal)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> parareal.forward_euler <span class="im">import</span> forward_euler</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="co"># from pintFoam.parareal.iterate_solution import iterate_solution</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> parareal.tabulate_solution <span class="im">import</span> tabulate</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> parareal.harmonic_oscillator <span class="im">import</span> (underdamped_solution, harmonic_oscillator)</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a><span class="co"># from uuid import uuid4</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> logging</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«example-mpi-main»</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>system <span class="op">=</span> harmonic_oscillator(OMEGA0, ZETA)</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«example-mpi-coarse»</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Coarse:</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    n_iter: <span class="bu">int</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    system: Any</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> solution(<span class="va">self</span>, y, t0, t1):</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> LiteralExpr(forward_euler(<span class="va">self</span>.system)(reduce_expr(y), t0, t1))</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>        logging.debug(<span class="ss">f&quot;coarse result: </span><span class="sc">{y}</span><span class="ss"> </span><span class="sc">{</span>reduce_expr(y)<span class="sc">}</span><span class="ss"> </span><span class="sc">{t0}</span><span class="ss"> </span><span class="sc">{t1}</span><span class="ss"> </span><span class="sc">{a}</span><span class="ss">&quot;</span>)</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«example-mpi-fine»</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_filename(name: <span class="bu">str</span>, n_iter: <span class="bu">int</span>, t0: <span class="bu">float</span>, t1: <span class="bu">float</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ss">f&quot;</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>n_iter<span class="sc">:04}</span><span class="ss">-</span><span class="sc">{</span><span class="bu">int</span>(t0<span class="op">*</span><span class="dv">1000</span>)<span class="sc">:06}</span><span class="ss">-</span><span class="sc">{</span><span class="bu">int</span>(t1<span class="op">*</span><span class="dv">1000</span>)<span class="sc">:06}</span><span class="ss">.h5&quot;</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Fine:</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    parent: Path</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    name: <span class="bu">str</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    n_iter: <span class="bu">int</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>    system: Any</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>    h: <span class="bu">float</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> solution(<span class="va">self</span>, y, t0, t1):</span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>        logger <span class="op">=</span> logging.getLogger()</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> math.ceil((t1 <span class="op">-</span> t0) <span class="op">/</span> <span class="va">self</span>.h)</span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> np.linspace(t0, t1, n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.parent.mkdir(parents<span class="op">=</span><span class="va">True</span>, exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>        path <span class="op">=</span> <span class="va">self</span>.parent <span class="op">/</span> generate_filename(<span class="va">self</span>.name, <span class="va">self</span>.n_iter, t0, t1)</span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> h5.File(path, <span class="st">&quot;w&quot;</span>) <span class="im">as</span> f:</span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true" tabindex="-1"></a>            logger.debug(<span class="st">&quot;fine </span><span class="sc">%f</span><span class="st"> - </span><span class="sc">%f</span><span class="st">&quot;</span>, t0, t1)</span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true" tabindex="-1"></a>            y0 <span class="op">=</span> reduce_expr(y)</span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true" tabindex="-1"></a>            logger.debug(<span class="st">&quot;:    </span><span class="sc">%s</span><span class="st"> -&gt; </span><span class="sc">%s</span><span class="st">&quot;</span>, y, y0)</span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> tabulate(forward_euler(<span class="va">self</span>.system), reduce_expr(y), t)</span>
<span id="cb44-25"><a href="#cb44-25" aria-hidden="true" tabindex="-1"></a>            ds <span class="op">=</span> f.create_dataset(<span class="st">&quot;data&quot;</span>, data<span class="op">=</span>x)</span>
<span id="cb44-26"><a href="#cb44-26" aria-hidden="true" tabindex="-1"></a>            ds.attrs[<span class="st">&quot;t0&quot;</span>] <span class="op">=</span> t0</span>
<span id="cb44-27"><a href="#cb44-27" aria-hidden="true" tabindex="-1"></a>            ds.attrs[<span class="st">&quot;t1&quot;</span>] <span class="op">=</span> t1</span>
<span id="cb44-28"><a href="#cb44-28" aria-hidden="true" tabindex="-1"></a>            ds.attrs[<span class="st">&quot;h&quot;</span>] <span class="op">=</span> <span class="va">self</span>.h</span>
<span id="cb44-29"><a href="#cb44-29" aria-hidden="true" tabindex="-1"></a>            ds.attrs[<span class="st">&quot;n&quot;</span>] <span class="op">=</span> n</span>
<span id="cb44-30"><a href="#cb44-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> H5Snap(path, <span class="st">&quot;data&quot;</span>, index[<span class="op">-</span><span class="dv">1</span>])</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«example-mpi-main»</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>y0 <span class="op">=</span> np.array([<span class="fl">1.0</span>, <span class="fl">0.0</span>])</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="fl">0.0</span>, <span class="fl">15.0</span>, <span class="dv">20</span>)</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>archive <span class="op">=</span> Path(<span class="st">&quot;./output/euler&quot;</span>)</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>underdamped_solution(OMEGA0, ZETA)(t)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>tabulate(Fine(archive, <span class="st">&quot;fine&quot;</span>, <span class="dv">0</span>, system, H).solution, LiteralExpr(y0), t)</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="co"># euler_files = archive.glob(&quot;*.h5&quot;)</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«example-mpi-history»</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> History:</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    archive: Path</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>    history: <span class="bu">list</span>[<span class="bu">list</span>[Vector]] <span class="op">=</span> field(default_factory<span class="op">=</span><span class="bu">list</span>)</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> convergence_test(<span class="va">self</span>, y) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>        logger <span class="op">=</span> logging.getLogger()</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.history.append(y)</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.history) <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> np.array([reduce_expr(x) <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>.history[<span class="op">-</span><span class="dv">2</span>]])</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> np.array([reduce_expr(x) <span class="cf">for</span> x <span class="kw">in</span> <span class="va">self</span>.history[<span class="op">-</span><span class="dv">1</span>]])</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>        maxdif <span class="op">=</span> np.<span class="bu">abs</span>(a <span class="op">-</span> b).<span class="bu">max</span>()</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>        converged <span class="op">=</span> maxdif <span class="op">&lt;</span> <span class="fl">1e-4</span></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>        logger.info(<span class="st">&quot;maxdif of </span><span class="sc">%f</span><span class="st">&quot;</span>, maxdif)</span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> converged:</span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>            logger.info(<span class="st">&quot;Converged after </span><span class="sc">%u</span><span class="st"> iteration&quot;</span>, <span class="bu">len</span>(<span class="va">self</span>.history))</span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> converged</span></code></pre></div>
</div>
<div class="named-code-block">
<p>«example-mpi-main»</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>archive <span class="op">=</span> Path(<span class="st">&quot;./output/parareal&quot;</span>)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> Parareal(</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    client,</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">lambda</span> n: Coarse(n, system).solution,</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">lambda</span> n: Fine(archive, <span class="st">&quot;fine&quot;</span>, n, system, H).solution)</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>jobs <span class="op">=</span> p.schedule(LiteralExpr(y0), t)</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>history <span class="op">=</span> History(archive)</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>p.wait(jobs, history.convergence_test)</span></code></pre></div>
</div>
</section>
</section>
        </div>
         <div class="col-3 col-s-3 menu" id="menu-container">
                <div id="menu"><nav id="TOC" role="doc-toc">
                                <ul>
                                <li><a href="#license">License</a></li>
                                <li><a href="#parareal">Parareal</a>
                                <ul>
                                <li><a href="#components">Components</a></li>
                                <li><a href="#parareal-1">Parareal</a></li>
                                <li><a href="#running-in-parallel">Running in parallel</a></li>
                                </ul></li>
                                <li><a href="#implementation-of-parareal-using-futures">Implementation of Parareal using Futures</a>
                                <ul>
                                <li><a href="#harmonic-oscillator">Harmonic oscillator</a></li>
                                </ul></li>
                                <li><a href="#example-using-hdf5-and-mpi-and-dask-futures">Example: using HDF5 and MPI and Dask futures</a>
                                <ul>
                                <li><a href="#best-practices">Best practices</a></li>
                                <li><a href="#dask-with-mpi">Dask with MPI</a></li>
                                <li><a href="#vector-arithmetic-expressions">Vector Arithmetic Expressions</a></li>
                                <li><a href="#running-the-harmonic-oscillator">Running the harmonic oscillator</a></li>
                                </ul></li>
                                </ul>
                </nav></div>
        </div> 
</div>
<div class="footer">
</div>
<!-- <script>
function toggle_dark_mode() {
    var app = document.getElementsByTagName("BODY")[0];
    if (localStorage.darkMode == "dark") {
	localStorage.darkMode = "light";
	app.setAttribute("dark-mode", "light");
    } else {
	localStorage.darkMode = "dark";
	app.setAttribute("dark-mode", "dark");
    }
}
</script> -->
</body>
</html>
